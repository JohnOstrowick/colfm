#include <QApplication>
#include <QShortcut>
#include <QMainWindow>
#include <QToolBar>
#include <QAction>
#include <QFileSystemModel>
#include <QFileIconProvider>
#include <QTreeView>
#include <QListView>
#include <QColumnView>
#include <QAbstractItemView>
#include <QSplitter>
#include <QDir>
#include <QIcon>
#include <QDebug>
#include <QLabel>
#include <QVBoxLayout>
#include <QHeaderView>
#include <QPixmap>
#include <QImage>
#include <QColor>
#include <QStyledItemDelegate>
#include <QProxyStyle>
#include <QStyle>
#include <QStatusBar>

#include "toolbars.h" // Breadcrumbs class

// -------- Settings --------
static const QSize kIconSize(32, 32);

enum class ViewMode { Tree, Column, Icon };

// Force app-wide 32 px icon metrics
class ForceIconStyle : public QProxyStyle {
public:
    using QProxyStyle::QProxyStyle;
    int pixelMetric(PixelMetric m, const QStyleOption *opt, const QWidget *wid) const override {
        if (m == QStyle::PM_SmallIconSize ||
            m == QStyle::PM_ListViewIconSize ||
            m == QStyle::PM_IconViewIconSize ||
            m == QStyle::PM_ToolBarIconSize) return 32;
        return QProxyStyle::pixelMetric(m, opt, wid);
    }
};

// Force the decoration (painted icon) to a fixed size
class FixedIconDelegate : public QStyledItemDelegate {
public:
    using QStyledItemDelegate::QStyledItemDelegate;
    void initStyleOption(QStyleOptionViewItem *option, const QModelIndex &index) const override {
        QStyledItemDelegate::initStyleOption(option, index);
        option->decorationSize = kIconSize;
    }
    QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const override {
        QStyleOptionViewItem opt(option);
        opt.decorationSize = kIconSize;
        return QStyledItemDelegate::sizeHint(opt, index);
    }
};

// Custom icon provider: tint symlinks teal, executables light green
class CustomIconProvider : public QFileIconProvider {
public:
    QIcon icon(const QFileInfo &info) const override {
        QPixmap pix = QFileIconProvider::icon(info).pixmap(kIconSize);
        QImage img = pix.toImage();

        if (info.isSymLink()) {
            for (int y = 0; y < img.height(); ++y)
                for (int x = 0; x < img.width(); ++x) {
                    QColor c = img.pixelColor(x, y);
                    if (c.alpha() > 0) {
                        c.setRgb((c.red()+0)/2, (c.green()+180)/2, (c.blue()+180)/2, c.alpha());
                        img.setPixelColor(x, y, c);
                    }
                }
            return QIcon(QPixmap::fromImage(img));
        }

        if (info.isExecutable() && !info.isDir()) {
            for (int y = 0; y < img.height(); ++y)
                for (int x = 0; x < img.width(); ++x) {
                    QColor c = img.pixelColor(x, y);
                    if (c.alpha() > 0) {
                        c.setRgb((c.red()+128)/2, (c.green()+255)/2, (c.blue()+128)/2, c.alpha());
                        img.setPixelColor(x, y, c);
                    }
                }
            return QIcon(QPixmap::fromImage(img));
        }

        return QFileIconProvider::icon(info);
    }
};

// QFileSystemModel that guarantees 32x32 decoration pixmaps (fixes symlink size)
class FixedFSModel : public QFileSystemModel {
public:
    using QFileSystemModel::QFileSystemModel;
    QVariant data(const QModelIndex &index, int role) const override {
        if (role == Qt::DecorationRole) {
            QVariant v = QFileSystemModel::data(index, role);
            QPixmap pm;
            if (v.canConvert<QIcon>()) {
                pm = qvariant_cast<QIcon>(v).pixmap(kIconSize);
            } else if (v.canConvert<QPixmap>()) {
                pm = qvariant_cast<QPixmap>(v);
            }
            if (!pm.isNull() && pm.size() != kIconSize) {
                pm = pm.scaled(kIconSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
            }
            if (!pm.isNull()) return pm;
            return v;
        }
        return QFileSystemModel::data(index, role);
    }
};

// ColumnView subclass that forces 32x32 icons and delegate for every spawned column
class ColumnView32 : public QColumnView {
public:
    using QColumnView::QColumnView;
protected:
    QAbstractItemView* createColumn(const QModelIndex &rootIndex) override {
        QAbstractItemView *v = QColumnView::createColumn(rootIndex);
        if (v) {
            v->setIconSize(kIconSize);
            v->setItemDelegate(new FixedIconDelegate(v));
        }
        return v;
    }
};

class ColFM : public QMainWindow {
public:
    ColFM(QWidget *parent=nullptr) : QMainWindow(parent) {
    model = new FixedFSModel(this);
    model->setIconProvider(new CustomIconProvider());
    model->setFilter(QDir::AllEntries | QDir::NoDotAndDotDot); // dotfiles hidden by default
    currentRoot = model->setRootPath(QDir::homePath());
    void setPreviewHtml(const QString &html, const QString &path);

    // Main toolbar FIRST (fixed row)
    tb = new QToolBar("Main Toolbar", this);
    tb->setMovable(false);
    addToolBar(Qt::TopToolBarArea, tb);
    drawButtons();

    // Force next toolbar onto its own row
    addToolBarBreak(Qt::TopToolBarArea);

    // Path bar SECOND row (editable current path)
    crumbs = new Breadcrumbs("Path", this);
    addToolBar(Qt::TopToolBarArea, crumbs);
    crumbs->setOnPathChosen([this](const QString &p){
        if (QDir(p).exists()) {
            currentRoot = model->index(p);
            setViewMode(mode);
        } else {
            statusBar()->showMessage("Path not found", 2000);
        }
    });
    crumbs->setPath(model->filePath(currentRoot));

	// Shortcuts: Space and Ctrl+I show preview of current selection
	new QShortcut(QKeySequence(Qt::Key_Space), this, [this]{
	    const QModelIndex idx = currentIndex();
	    if (idx.isValid()) previewFile(idx);
	});
	new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_I), this, [this]{
	    const QModelIndex idx = currentIndex();
	    if (idx.isValid()) previewFile(idx);
	});


    setViewMode(ViewMode::Tree);
    setWindowTitle("ColFM — Multi-View File Manager");
    resize(1400, 800);
}

private:
    // Model and state
    FixedFSModel *model{};
    ViewMode mode = ViewMode::Tree;
    QModelIndex currentRoot;
    QLabel *previewLabel{};
    bool showHidden = false;
    bool eventFilter(QObject *obj, QEvent *ev) override;

    // UI
    Breadcrumbs *crumbs{};
    QToolBar *tb{};
    QAction *actTrash{}, *actRefresh{}, *actOpenTrash{}, *actUp{};
    QAction *actOpen{}, *actClose{}, *actInfo{}, *actRename{}, *actMove{}, *actDuplicate{}, *actLink{};
    QAction *treeBtn{}, *columnBtn{}, *iconBtn{}, *toggleHiddenBtn{};

	QAbstractItemView *currentView{}; // track active view

	// open/preview API
	QModelIndex currentIndex() const;
	bool isImageFile(const QString &path) const;
	void previewFile(const QModelIndex &idx);
	void openFile(const QModelIndex &idx);
	void openApp(const QString &path);

    // Declarations only — defined in actions.h
    void drawButtons();

    void onMoveToTrash();
    void onRefresh();
    void onOpenTrash();

    void onUp();
    void onOpen();
    void onCloseAction();
    void onInfo();
    void onRename();
    void onMove();
    void onDuplicate();
    void onCreateSoftlink();

    void onToggleHidden();

    void onViewTree();
    void onViewColumn();
    void onViewIcon();

    // View builders — declarations only; bodies in viewwidgets.h
    QWidget* buildTreeWidget(const QModelIndex &root);
    QWidget* buildColumnWidget(const QModelIndex &root);
    QWidget* buildIconWidget(const QModelIndex &root);

    void setViewMode(ViewMode m) {
        mode = m;
        QWidget *old = centralWidget();
        if (old) old->deleteLater();
        QWidget *w = nullptr;
        QModelIndex root = currentRoot.isValid() ? currentRoot : model->index(QDir::homePath());
        switch (mode) {
            case ViewMode::Tree:   w = buildTreeWidget(root);   break;
            case ViewMode::Column: w = buildColumnWidget(root); break;
            case ViewMode::Icon:   w = buildIconWidget(root);   break;
        }
        setCentralWidget(w);
        if (crumbs) crumbs->setPath(model->filePath(currentRoot));
    }
};

// Out-of-class method definitions
#include "viewwidgets.h"
#include "actions.h"
#include "handleopen.h"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    app.setStyle(new ForceIconStyle(app.style()));
    app.setWindowIcon(QIcon("icons/app_icon.png"));
    ColFM w; w.show();
    return app.exec();
}
